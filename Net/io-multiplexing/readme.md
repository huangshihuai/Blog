# I/O multiplexing

## 什么是I/O 多路复用
```
当有一个或多个事件就绪时将通知.
If one or more I/O conditions are ready will notification.
```

## 它能解决什么问题?
```
它能帮助开发者管理文件句柄, 探测感兴趣的事件是否发生.
    * I/O多路复用至少可以管理1024个文件句柄.
    * I/O多路复用所管理的句柄它异步事件, 效率和性能比应用程序loop更高.
```

## 惊群问题
```
它更多描述CPU空转, 被唤醒却无事可做.
    * 我们养了至少10只鸡, 但你有3粒米, 为了公平起见, 我们将三粒米抛入鸡群中.
    * 有2种结果:
        * 3只鸡吃到了米, 7只鸡干瞪眼.
        * 1只鸡把三粒米全吃了, 9只鸡干瞪眼.
```

## 为什么会有惊群问题?
```
    * 由于linux 文件描述符是引用关系(根因), 其次将fd共享在I/O多路复用之中(例如accept fd)
        * 当我们引用同一个文件句柄, 并且将它放在I/O多路复用中, 但事件到达时, 操作系统只能将其全部唤醒.
```

## 我们该如何避免它
```
    * 避免将同一个fd共享在多个I/O复用器内
    * 避免并发操作同一个fd
```

## select
```
    * 监听文件句柄有限, 默认是1024, 除非修改系统内核.
    * 线性遍历, 由于文件句柄有限, 其性能不差, 少量文件句柄适合
```

## poll
```
    * 修复select的弊端, 去除了文件句柄上限的限制.
    * 以链表(数据结构)维护fd, 线性遍历, 当文件句柄太多时, 性能下降很快.
```

## epoll
```
    * 修复poll的弊端, 以红黑树的数据结构维护fd, 二分查找.
    * 基于事件的IO多路复用
```

![image](/Picture/benchmark.png)