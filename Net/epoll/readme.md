# epoll
```
epoll 对新手来说是一个麻烦事, 半知不解中夹杂着疑问.
我将介绍以下部分:
    * epoll 的线程安全
    * epoll 的一些flag(ET LT EPOLLONESHOT)
    * epoll 是否解决了惊群
```

## epoll线程安全吗?
```
首先它是非线程安全的, 可能有些同学该要问了: 从内核代码上看它是线程安全的(kernel 3.5以上)
    * 原因是:  有些内核版本的epoll它是不安全.
所以, 现有较多开源网络框架把对epoll的操作都集中在I/O线程上.
```
## [epoll丢失感兴趣文件描述符 - patch](https://lore.kernel.org/patchwork/patch/351273/)

## epoll 的一些flag(ET LT EPOLLONESHOT)

### ET[边缘触发]
```
怎么理解它?
    * 在每一次可读可写事件到达时, 将只会告知一次状态, 需要应用程序保证读写I/O的完整性. 如果没有全部读取完毕, 只能等待下次数据状态到达/改变.
        * 判断读写完整性errno错误码为EAGAIN
优势:
    * 它性能最高, 因为维护的就绪句柄文件较少.
劣势:
    * 但容错性差, 开发难度大.
```

### LT
```
怎么理解它?
    * 它始终将通知应用程序读写状态, 防止因为socket状态没处理好而丢失文件句柄.
优势:
    * 性能先对ET较差
劣势:
    * 但开发要求较低, 容错性较大.
```

### EPOLLONESHOT
```
怎么理解它?
    * 每次事件都将从epoll集合中移除, 需要应用程序再次ctl到epoll中.
应用场景:
    * 可以将task派发到work线程中处理, 读写I/O和业务逻辑处理与I/O线程剥离.
优势:
    * 避免在I/O线程上(epoll)处理业务逻辑.
    * 避免阻塞I/O线程, 从而影响处理I/O的速度.
劣势:
    * 多一次系统调用
```

## epoll 是否解决了惊群
```
结论: 未解决, 只是将问题隐藏得更深了而已.
```

### EPOLLEXCLUSIVE
```
怎么理解它?
    * 将同一个fd共享在多个epoll集合中时, 它保证了原子唤醒, 也就是理论上不会出现惊群问题.
实际现象:
    * 惊群依然存在, 原因是其他flag影响了.
EPOLLET & EPOLLEXCLUSIVE
    * EPOLLET 仅被通知一次, EPOLLEXCLUSIVE 保证原子唤醒.
    * socket可读/可写状态需要一次读写调用获得, 而且仅当前状态. 对于下次socket状态需要在此读写, 通过读写socket, 通过其错误码判定当前socket是否可读/可写.(总结: 对于socket状态需要一次的系统调用获得)
    * 边界: 当我们处于可读到不可读的临界点时(可写到不可写), 这时网卡数据发生改变, 再次触发一次信号.
    * 如何响应: epoll将再次被唤醒, 出现了读写竞争/惊群
```



## close fd 会从epoll中移除?