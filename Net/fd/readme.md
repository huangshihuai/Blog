# file description
```
linux 一切的文件操作皆是文件,  磁盘 网络 cpu数据 网卡状态等.
用户态的文件描述符引用内核态的文件描述符, 内核态持有引用计数.
```

## 问题1 - 文件句柄泄漏
```
产生问题的原因:
    * 在fork 和 exec 时父进程的文件句柄被子进程继承, 将导致文件句柄泄漏.
解决方案:
    * 在创建文件句柄时添加上close-on-exec 状态.
```

## 问题2 - 数据乱序
```
产生问题的原因:
    * 用户态&内核态是引用关系, 多进程(多线程)可以同时读写.
    * 可写buffer空间有限, 用户态数据可能需要多次写buffer, 将导致竞争写缓冲.
    * 可读buffer空间不确定, 用户态所读的buffer 并不一定能满足这次协议解析.
```
![image](/Picture/multi_read.png)

## 问题3 - shutdown & close 区别
```
shotdown 和 close 的区别在于是否直接关闭fd.
close 将内核态的引用计数减一, 如果引用计数为0 将关闭fd.
shutdown 将直接关闭所传递的flag(RD, WD, RWD).
```

## 问题4 - 鲸群
```
鲸群问题 根因是文件描述符引用.
    * 当我们将文件描述符共享在I/O多路复用, 当fd状态发生改变, 内核将通知所有持有该文件句柄的I/O多路复用器, 将导致读写竞争, 和鲸群.
其他问题:
    * 在epoll 新增EPOLLEXCLUSIVE, 从代码角度看是解决了鲸群问题, 不过它并没有彻底解决, 只是被隐藏得更深了.
```
[参见epoll](../epoll/readme.md)
