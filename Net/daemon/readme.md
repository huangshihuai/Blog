# daemon

## 什么是守护进程
```
常驻后台, 脱离终端限制, 拥有自主控制权的独立进程.
```

## 为什么需要转变为守护进程
```
在后台开发, 我们需要处理将服务(http-server), 脚本转变为后台进程，但如果我们退出session(退出终端)进程极有可能被内核 kill(我遇到过～_～).
    * 当我们退出session时, 操作系统将对session发送SIGHUP, 
    * session 将信号发送到其所属的子进程, 子进程接收到SIGHUP后退出.
```

## 该如何处理
```
1. 将进程转变为守护进程一般有2种方式
    * 利用systemd、nohup、disown
    * 编写守护进程(主讲)
2. 编写守护进程 - 注意事项
    * 将进程转变为后台进程
    * 清除文件组权限限制
    * 重建进程组
    * 关闭与终端的联系
```

## 将进程转变为后台进程
```
为何要做:
    * 进程需要脱离终端窗口(terminal), 视觉效果与终端没有联系.
    * 子进程将被init进程所接管.
如何做:
    * 父进程创建子进程, 父进程退出.
有何问题:
    * 谨防文件句柄泄漏和多进程同时读写同一文件句柄(fd)
为什么有这个问题:
    * Linux文件系统中, 用户态的文件句柄是引用内核态, 在内核态持有引用计数.
    * 如果是多进程同时引用同一文件句柄, 那么它只是句柄泄漏
    * 如果是多进程同时读写同一文件句柄, 那么它是不可靠的(例如: 鲸群、数据乱序等)
如何避免:
    * 在创建文件句柄时添加上close-on-exec
其他问题:
    * 父进程为什么需要退出? 原因是: 主进程与终端紧密联系, 我们可以通过子进程方便的转变为后台进程.
```

## 清除文件组权限限制
```
为何要做:
    * 服务进程由当前用户组启动, 进程带有当前用户组的权限掩码(umask), 会限制访问系统资源.
如何做:
    * umask(0);
有何问题:
    * 无
```

## 重建进程组
```
为何要做:
    * 父进程退出后, 子进程没有拥有独立的进程组(虽然它被init进程接管).
如何做:
    * setsid()
其他问题:
    * 仅影响非进程组leader, 如果调用进程不是进程组leader, 则创建一个新会话.
```

## 关闭与终端的联系
```
为何要做:
    * 当一个进程以后台形式启动，但尝试去读写控制台终端时，将会触发SIGTTIN(读)和SIGTTOU(写)信号, 该信号将kill本进程
如何做:
    * 关闭 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO
    * 将 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO 指向 /dev/null 的文件句柄
问题:
    * 暂无
注意事项:
    * 文件描述符始终返回最小的fd
```

![image](/Picture/daemon.png)

## [参考代码](https://github.com/huangshihuai/hyper/blob/master/net/net_server.cpp)